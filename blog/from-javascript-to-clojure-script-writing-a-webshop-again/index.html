<!DOCTYPE html><html lang=en><head><meta charset=UTF-8><title>From JavaScript to Clojure(Script): Writing a webshop, again - Telia TechBlog</title><meta name=description content="In which I explain why Norway&#39;s second largest mobile operator is experimenting with using Clojure and ClojureScript instead of Node and JavaScript for its new webshop and what the experience has been so far."><meta property=og:title content="From JavaScript to Clojure(Script): Writing a webshop, again"><meta property=og:description content="In which I explain why Norway&#39;s second largest mobile operator is experimenting with using Clojure and ClojureScript instead of Node and JavaScript for its new webshop and what the experience has been so far."><meta property=og:site_name content="Telia TechBlog"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=https://nettbutikk.netcom.no/img/favicon.ico><link rel=stylesheet href=/css/style.css><link rel=alternate type=application/rss+xml title="Telia TechBlog" href=/rss.xml></head><body><div class=site-wrap><header class="site-header px2 px-responsive"><div class="mt2 wrap"><div class=measure><a href="/" class=site-title>Telia TechBlog</a><nav class="site-nav right"><a href=/projects>About</a> <a href="http://telianorge.no/">Telia</a></nav><div class=clearfix></div></div></div></header><div class="post p2 p-responsive wrap" role=main><div class=measure><div class=post><header class="post-header mb2"><h1>From JavaScript to Clojure(Script): Writing a webshop, again</h1><span class=post-meta>By Jakub Hol√Ω on Dec 22, 2017</span><br><span class="post-meta small"><a href=/tags/nettbutikk title=nettbutikk>nettbutikk</a>, <a href=/tags/b2b title=b2b>b2b</a>, <a href=/tags/clojurescript title=clojurescript>clojurescript</a>, <a href=/tags/clojure title=clojure>clojure</a></span></header><article class="post-content py2"><p>In which I explain why Norway&#39;s second largest mobile operator is experimenting with using Clojure and ClojureScript instead of Node and JavaScript for its new webshop and what the experience has been so far.</p><p><em>Aside - about us: <a href=https://telia.no>Telia Norge</a> is Norway&#39;s second largest mobile operator. Our team is responsible for serving its customers who want to buy subscriptions or hardware (phones, tablets, routers, and accessories) without attending a physical shop.</em></p><p><em><strong>Updated</strong> on Jan 9th - added &quot;easier to get help&quot;, improved wording</em></p><h2 id=background>Background</h2><p>Three years ago, a small team of experienced developers with an agile and rebellious mindset has been hired for an experiment. The hypothesis was that such a team, sitting together with the business, could increase conversion rates and profitability of the company webshop by enabling rapid development and implementation of business ideas/hypotheses/experiments, tailoring the webshop for what customers needed and wanted. Replacing a webshop from scratch is no simple task but we proceeded one page at a time and the experiment concluded as a glaring success earlier than planned, turning over to a regular product development. A year and something later, we could finally pull the plug on the old webshop.</p><p>We have originally picked JavaScript and React for the frontend and Node.js for the backend, and we have never regretted the choice. Though two of us three had minimal previous experience with these technologies and language, we managed to learn quickly.</p><p>Fast forward to the present. We now have a full-featured, mature webshop that has been recently evaluated as <a href=http://digitalleaders.bearingpoint.com/media/1031/digital-leaders-in-norway-2018-web.pdf>the third best customer-oriented webshop in Norway</a> (the first place being taken by the only alcohol-selling state company, Vinmonopolet). There is a never-ending stream of work to be done to improve the customer experience, <a href="/blog/today-we-write-the-legacy-code-of-tomorrow/">cleanup aged code</a>, and support new business and marketing ideas but we are quite happy with what we have.</p><h2 id=why-clojure-script->Why Clojure(Script)?</h2><p>It has been now decided to give some love also to our long sidelined business customers and create a dedicated webshop tuned to their needs. The webshops for end-customers (B2C) and businesses and organizations (B2B) are likely to differ significantly so it makes sense to start the new webshop from scratch, while finding ways of reusing what makes sense to reuse (though beware the <a href="http://johannesbrodwall.com/2014/03/24/the-economics-of-reuse/">economics of reuse</a>). When starting a project from scratch, why not also take a (careful) look at the technologies invovled?</p><p>Introducing a new technology is obviously a very serious decision, with a non-negligible cost. Yet the gain is sometimes worth it. Let&#39;s look at our evaluation of ES6 on Node / browser vs. Clojure and ClojureScript. We want to use the (almost) same language on frontend and backend as we have a positive experience with that from the current project. And we prefer Clojure on JVM over ClojureScript on Node because it is more mature and we prefer the JVM.</p><p>Let&#39;s look first at a brief overview of the pros and cons, ordered by importance:</p><p>Pros:</p><ol><li>productivity</li><li>economy (and fun)</li><li>hiring</li><li>skillset</li><li>powerful language - immutable data and data manipulation library, macros, much more &quot;good parts&quot; than &quot;bad parts&quot;, less code - fewer bugs</li><li>JVM</li><li>easier to get help</li></ol><p>Cons:</p><ol><li>learning curve (language, tools, best practices)</li><li>hiring</li><li>troubleshooting</li><li>setup from scratch</li><li>Dev Tools for React/Redux more mature</li></ol><h3 id=pros-cons-in-detail>Pros &amp; cons in detail</h3><h4 id=pros>Pros</h4><p><strong>Productivity</strong> was our absolute #1 reason for selecting Clojure(Script). We have been sold on the language since we have seen Bruce Hauman&#39;s <a href="https://www.youtube.com/watch?v=KZjFVdU8VLI">Interactive programming Flappy Bird in ClojureScript</a> years ago. Clojure(Script) gives you a REPL connected to your live application so that you can run code in its context, against its current state, and develop the application as it is running. You can continually evaluate snippets of code as you develop it, just one shortcut away from a feedback on the code you have just modified. I missed that terribly in Node, having to wait for babel to transpile the code and the application to restart and re-fetch the data it needed, providing feedback loop of 10-20 sec at minimum. (We were on our way to cutting that to 1 or few seconds but still it wouldn&#39;t be instant - and the application would still lose all local state at every code change.)</p><p><strong>Economy (and fun)</strong> There are very few Clojure jobs in Oslo yet the Clojure meetups are packed by tens of passionate developers. By using Clojure we ensure that people will stay longer on the team because they haven&#39;t that many places to go and because they will have fun working with it. Fun is an underrated aspect. A developer that deeply enjoys working with the language, technology, and ecosystem he or she uses at work is happy and thus more productive. He or she is more likely to put in an extra effort, and will probably brag about it, thus attracting more talent. And we get to keep the developer or two that are always looking for an opportunity where they could use Clojure at work.</p><p><strong>Hiring</strong> capable developers is difficult. Being able to provide something few others have is thus a great advantage. Yes, there are far fewer Clojure(Script) then for instance Java developers, but given the disproportion of supply-demand in both cases, <a href="https://blog.iterate.no/2013/04/18/economies-of-scala/">it is comparatively much easier to hire the former</a>. As mentioned above, there are many more Clojure enthusiast than Clojure jobs in Oslo. And a developer to be hired doesn&#39;t need to know the language as long as he is attracted by it and willing to learn. Many people have managed transitioning from Ruby, Java, or JavaScript to Clojure(Script) quite easily (including a teammate). We can also assume that <a href=http://www.paulgraham.com/avg.html>people that learn a non-mainstream, Lisp language are more passionate and likely better developers</a>.</p><p><strong>Skillset</strong> Our team is somewhat unique - half of it, and soon more than that, has experience with Clojure or ClojureScript (and desire to use it). That is more than we could say about JavaScript when we started using that.</p><p><strong>Powerful language - immutable data, data manipulation, macros, great design</strong> are some of the often highlighted strengths of Clojure(Script). We already use seamless-immutable to decrease defect likelihood, however imperfect it is by definition, being added to a deeply mutable language, and we use Lodash extensively when processing data. Clojure gives us a much better alternatives to both. We can limit boilerplate through the all-powerful macros (that, hopefully, somebody else has written :-)). And, last but not least, Clojure is a language with a very well thought-through design, whose pieces generally fit very well together. It is not perfect, but few have got closer to perfection so far. That is contrary to JavaScript, whose design - despite some great ideas - is somewhat messy and that keeps growing somewhat organically. <a href=https://medium.freecodecamp.org/a-real-world-comparison-of-front-end-frameworks-with-benchmarks-e1cb62fd526c>Clojure codebases reportedly tend to be visibly smaller</a> than those in Java or JavaScript, and code size is one of the key factors determining the amount of defects, so we can hope we will get a lower defect rate.</p><p><strong>JVM</strong> Personally, I believe that JVM has superior monitoring and observability capabilities to Node, though I am obviously biased by me experience. So I prefer to have that on the server-side.</p><p><strong>Easier to get help</strong> - Clojure(Script) has a very active and helpful community. When I have a Java or JavaScript problem, I can ask at StackOverflow. With Clojure I can also ask at its awesome <a href=https://groups.google.com/d/forum/clojure>mailing list</a> (frequented by core developers and all famous people and creators) and, for even a more timely advice, use the <a href=clojurians.slack.com>Clojurians Slack</a> instant messaging (with channels devoted also to individual libraries and tools, frequented by the authors). It has never disappointed me (and I learn a lot by following them).</p><h4 id=cons>Cons</h4><p><strong>Learning curve</strong> Using a new language and framework requires time to learn. Some may find ClojureScript more difficult since, being a Lisp, it differs from the familiar C/Java/JavaScript. On the other hand, we all already know it - and are thus in a better position than when we started the B2C webshop. Most of our current developers had no or little JavaScript knowledge when they started on the project so we have some experience with learning on the job. Our junior developer who is new to Clojure has been doing very well so far.</p><p><strong>Hiring</strong> is theoretically more difficult as there are far fewer Clojure(Script) programmers than JavaScript ones. On the other hand, as explained above, it might actually be easier.</p><p><strong>Troubleshooting</strong> of runtime errors is more difficult. Clojure is infamous for its long stack traces and not all that useful error messages such as &quot;java.lang.Long cannot be cast to clojure.lang.IFn&quot; (especially compared to the awesome Elm). We have experienced a few but were lucky to solve them quickly. I guess the antidote is to really adopt REPL-driven development, where we incrementally build tiny, working pieces of code (that are so small that they are trivial to troubleshoot), an occasional use of spec and pre-/postconditions, and careful reading of the code we have written. One of the errors - re-frame complaining about being passed a function because we mistakenly invoked a two-argument version of it - could just as well happen in an equally dynamically typed JavaScript.</p><p><strong>Setup from scratch</strong> - it will be necessary to set up all integration and plumbing (error reporting, logging, metrics, etc.) anew, while we already have these concerns solved in our current Node.js setup. That is unfortunate, but it is just a one-time, and hopefully relatively low cost. And there are typically quite mature and high-quality libraries.</p><p><strong>Dev Tools for React/Redux more mature</strong> - especially the Redux Dev Tools are more mature at useful than re-frisk we use with re-frame. We are working further away from the browser&#39;s native language so using its built-in and quite evolved tools isn&#39;t always that helpful. We need cljs-devtools with custom formatters etc. to get what JavaScript developers get out of the box. On the other hand, they have nothing like the REPL so in total we are on the winning side :-)</p><h4 id=aside-what-makes-the-js-clj-transition-easier>Aside: What makes the JS -&gt; Clj transition easier</h4><p>Transitioning from JavaScript to Clojure(Script) is easier than from Java, especially in this team, for a couple of reasons:</p><ul><li>We rarely use a debugger for Node so we won&#39;t miss it. (Though e.g. Cursive&#39;s debugger is available and possibly as good as Node&#39;s?)</li><li>JS is dynamically typed so that is nothing new to us.</li><li>We already structure code in modules with pure function, using very little object-oriented programming.</li><li>We are already used to destructuring from ES6.</li><li>We already transpile (and webpack) our JavaScript so using ClojureScript that needs transpilation doesn&#39;t really add a new step.</li></ul><h2 id=our-experiences-so-far>Our experiences so far</h2><p>Plus:</p><ul><li>Hot reloading works AND preserves state</li><li>You can bring the app into any desired state easily from the REPL without clicking around</li><li>You can interact with and explore the live app in its current state from the REPL</li><li>We get useful warnings from re-frame when we are missing a handler or a query</li><li>See also our <a href="https://techblog.telia.no/blog/experience-awesome-productivity-with-clojurescript-s-repl/">Experience: Awesome productivity with ClojureScript&#39;s REPL</a></li></ul><p>Minus:</p><ul><li>Redux DevTools are better; in re-frisk we could only see the current, not past states (NOTE: That has been fixed in the latest version of re-frisk)</li><li>Errors in the browser are often more difficult to troubleshoot (despite working source maps ;)). Positive: it often names the failing component.</li></ul><h3 id=summary>Summary</h3><p>Our team is in a unique position as we have multiple people - possibly 100% of the team - that have Clojure and/or ClojureScript experience. Therefore it makes sense to leverage the increased productivity of Clojure(Script). At the same time, the developers will be more happy, work harder, and less likely to leave. And we might have a unique opportunity to overcome our chronic hiring challenges by offering something few others do.</p><p>So far, the past few weeks, has our experience been very positive.</p><p><em>Update: You can read about our experiences with hiring in <a href="/blog/experience-report-hiring-for-clojure-script-is-easy/">Experience Report: Hiring for Clojure(Script) is Easy</a></em></p><h2 id=appendix-our-stack>Appendix: Our stack</h2><p>We have selected Reagent (react wrapper) and re-frame (change+state handling, derived state). This combination is battle-tested, mature, and popular. Reagent is attractive because it requires zero boilerplate, you just write functions with Hiccup data to create components, so it is much easier to sell to developers than Om. Re-frame is also quite close to Redux and thus easier to understand for a team used to Redux. The main disadvantage is that there is no native server-side rendering (which might be important for us); people solve it by running the code on the JVM&#39;s JavaScript engine or by running it on Node.js. There are also rough edges around usage with DevCards due to the reliance on global state.</p><p>We have also considered Om Next, as it is nicely &quot;decomplected,&quot; has nice features such as undo and optimistic changes, and supports server-side rendering natively. But it is more verbose (you need to define a class with a <code>render</code> function) and has steeper learning curve and is thus more difficult to &quot;sell&quot;. (I would actually consider <a href=https://fulcrologic.github.io/fulcro/vsom-next.html>Falcro</a> instead; it provides less freedom but is easier to set up and provides some features Om Next cannot.)</p><p><em>(You might want to read other posts from <a href=/tags/nettbutikk>our rebellious product development series</a>)</em></p></article></div></div></div></div><footer class=footer><div class="p2 wrap"><div class="measure mt1 center"><p><small>Do you want to know more? <a href=https://telianorge.no/karrierer>Work with us!</a></small></p><small>Made by Telia Norge AS</small></div></div></footer><script src=/js/scripts.js></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-65719787-2', 'auto');
  ga('send', 'pageview');</script></body></html>