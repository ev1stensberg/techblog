{"name":"posts","total":12,"result":[{"title":"From JavaScript to Clojure(Script): Writing a webshop, again","date":"2017-12-22T00:00:00.000Z","author":"Jakub Hol√Ω","tags":["nettbutikk","b2b","clojurescript"],"contents":"<p>In which I explain why Norway&#39;s second largest mobile operator is experimenting with using Clojure and ClojureScript instead of Node and JavaScript for its new webshop and what the experience has been so far.</p>\n<p><em>Aside - about us: <a href=\"https://telia.no\">Telia Norge</a> is Norway&#39;s second largest mobile operator. Our team is responsible for serving its customers who want to buy subscriptions or hardware (phones, tablets, routers, and accessories) without attending a physical shop.</em></p>\n<p><em><strong>Updated</strong> on Jan 9th - added &quot;easier to get help&quot;</em></p>\n<h2 id=\"background\">Background</h2>\n<p>Three years ago, a small team of experienced developers with an agile and rebellious mindset has been hired for an experiment. The hypothesis was that such a team, sitting together with the business, could increase conversion rates and profitability of the company webshop by enabling rapid development and implementation of business ideas/hypotheses/experiments, tailoring the webshop for what customers needed and wanted. Replacing a webshop from scratch is no simple task but we proceeded one page at a time and the experiment concluded as a glaring success earlier than planned, turning over to a regular product development. A year and something later, we could finally pull the plug on the old webshop.</p>\n<p>We have originally picked JavaScript and React for the frontend and Node.js for the backend, and we have never regretted the choice. Though two of us three had minimal previous experience with these technologies and language, we managed to learn quickly.</p>\n<p>Fast forward to the present. We now have a full-featured, mature webshop that has been recently evaluated as <a href=\"http://digitalleaders.bearingpoint.com/media/1031/digital-leaders-in-norway-2018-web.pdf\">the third best customer-oriented webshop in Norway</a> (the first place being taken by the only alcohol-selling state company, Vinmonopolet). There is a never-ending stream of work to be done to improve the customer experience, <a href=\"/blog/today-we-write-the-legacy-code-of-tomorrow/\">cleanup aged code</a>, and support new business and marketing ideas but we are quite happy with what we have.</p>\n<h2 id=\"why-clojure-script-\">Why Clojure(Script)?</h2>\n<p>It has been now decided to give some love also to our long sidelined business customers and create a dedicated webshop tuned to their needs. The webshops for end-customers (B2C) and businesses and organizations (B2B) are likely to differ significantly so it makes sense to start the new webshop from scratch, while finding ways of reusing what makes sense to reuse (though beware the <a href=\"http://johannesbrodwall.com/2014/03/24/the-economics-of-reuse/\">economics of reuse</a>). When starting a project from scratch, why not also take a (careful) look at the technologies invovled?</p>\n<p>Introducing a new technology is obviously a very serious decision, with a non-negligible cost. Yet the gain is sometimes worth it. Let&#39;s look at our evaluation of ES6 on Node / browser vs. Clojure and ClojureScript. We want to use the (almost) same language on frontend and backend as we have a positive experience with that from the current project. And we prefer Clojure on JVM over ClojureScript on Node because it is more mature and we prefer the JVM.</p>\n<p>Let&#39;s look first at a brief overview of the pros and cons, ordered by importance:</p>\n<p>Pros:</p>\n<ol>\n<li>productivity</li>\n<li>economy (and fun)</li>\n<li>hiring</li>\n<li>skillset</li>\n<li>powerful language - immutable data and data manipulation library, macros, much more &quot;good parts&quot; than &quot;bad parts&quot;, less code - fewer bugs</li>\n<li>JVM</li>\n<li>easier to get help</li>\n</ol>\n<p>Cons:</p>\n<ol>\n<li>learning curve (language, tools, best practices)</li>\n<li>hiring</li>\n<li>troubleshooting</li>\n<li>setup from scratch</li>\n<li>Dev Tools for React/Redux more mature</li>\n</ol>\n<h3 id=\"pros-cons-in-detail\">Pros &amp; cons in detail</h3>\n<h4 id=\"pros\">Pros</h4>\n<p><strong>Productivity</strong> was our absolute #1 reason for selecting Clojure(Script). We have been sold on the language since we have seen Bruce Hauman&#39;s <a href=\"https://www.youtube.com/watch?v=KZjFVdU8VLI\">Interactive programming Flappy Bird in ClojureScript</a> years ago. Clojure(Script) gives you a REPL connected to your live application so that you can run code in its context, against its current state, and develop the application as it is running. You can continually evaluate snippets of code as you develop it, just one shortcut away from a feedback on the code you have just modified. I missed that terribly in Node, having to wait for babel to transpile the code and the application to restart and re-fetch the data it needed, providing feedback loop of 10-20 sec at minimum. (We were on our way to cutting that to 1 or few seconds but still it wouldn&#39;t be instant - and the application would still lose all local state at every code change.)</p>\n<p><strong>Economy (and fun)</strong> There are very few Clojure jobs in Oslo yet the Clojure meetups are packed by tens of passionate developers. By using Clojure we ensure that people will stay longer on the team because they have nowhere to go and because they will have fun working with it. Fun is an underrated aspect. A developer that deeply enjoys working with the language, technology, and ecosystem he or she uses at work is happy and thus more productive. He or she is more likely to put in an extra effort, and will probably brag about it, thus attracting more talent. And we get to keep the developer or two that are always looking for an opportunity where they could use Clojure at work.</p>\n<p><strong>Hiring</strong> capable developers is difficult. Being able to provide something few others have is thus a great advantage. Yes, there are far fewer Clojure(Script) then for instance Java developers, but given the disproportion of supply-demand in both cases, <a href=\"https://blog.iterate.no/2013/04/18/economies-of-scala/\">it is comparatively much easier to hire the former</a>. As mentioned above, there are many more Clojure enthusiast than Clojure jobs in Oslo. And a developer to be hired doesn&#39;t need to know the language as long as he is attracted by it and willing to learn. Many people have managed transitioning from Ruby, Java, or JavaScript to Clojure(Script) quite easily (including a teammate). We can also assume that <a href=\"http://www.paulgraham.com/avg.html\">people that learn a non-mainstream, Lisp language are more passionate and likely better developers</a>.</p>\n<p><strong>Skillset</strong> Our team is somewhat unique - half of it, and soon more than that, has experience with Clojure or ClojureScript (and desire to use it). That is more than we could say about JavaScript when we started using that.</p>\n<p><strong>Powerful language - immutable data, data manipulation, macros, great design</strong> are some of the often highlighted strengths of Clojure(Script). We already use seamless-immutable to decrease defect likelihood, however imperfect it is by definition, being added to a deeply mutable language, and we use Lodash extensively when processing data. Clojure gives us a much better alternatives to both. We can limit boilerplate through the all-powerful macros (that, hopefully, somebody else has written :-)). And, last but not least, Clojure is a language with a very well thought-through design, whose pieces generally fit very well together. It is not perfect, but few have got closer to perfection so far. That is contrary to JavaScript, whose design - despite some great ideas - is somewhat messy and that keeps growing somewhat organically. <a href=\"https://medium.freecodecamp.org/a-real-world-comparison-of-front-end-frameworks-with-benchmarks-e1cb62fd526c\">Clojure codebases reportedly tend to be visibly smaller</a> than those in Java or JavaScript, and code size is one of the key factors determining the amount of defects, so we can hope we will get a lower defect rate.</p>\n<p><strong>JVM</strong> Personally, I believe that JVM has superior monitoring and observability capabilities to Node, though I am obviously biased by me experience. So I prefer to have that on the server-side.</p>\n<p><strong>Easier to get help</strong> - Clojure(Script) has a very active and helpful community. When I have a Java or JavaScript problem, I can ask at StackOverflow. With Clojure I can also ask at its awesome <a href=\"https://groups.google.com/d/forum/clojure\">mailing list</a> (frequented by core developers and all famous people and creators) and, for even a more timely advice, use the <a href=\"clojurians.slack.com\">Clojurians Slack</a> instant messaging (with channels devoted also to individual libraries and tools, frequented by the authors). It has never disappointed me (and I learn a lot by following them).</p>\n<h4 id=\"cons\">Cons</h4>\n<p><strong>Learning curve</strong> Using a new language and framework requires time to learn. Some may find ClojureScript more difficult since, being a Lisp, it differs from the familiar C/Java/JavaScript. On the other hand, we all already know it - and are thus in a better position than when we started the B2C webshop. Most of our current developers had no or little JavaScript knowledge when they started on the project so we have some experience with learning on the job. Our junior developer who is new to Clojure has been doing very well so far.</p>\n<p><strong>Hiring</strong> is theoretically more difficult as there are far fewer Clojure(Script) programmers than JavaScript ones. On the other hand, as explained above, it might actually be easier.</p>\n<p><strong>Troubleshooting</strong> of runtime errors is more difficult. Clojure is infamous for its long stack traces and not all that useful error messages such as &quot;java.lang.Long cannot be cast to clojure.lang.IFn&quot; (especially compared to the awesome Elm). We have experienced a few but were lucky to solve them quickly. I guess the antidote is to really adopt REPL-driven development, where we incrementally build tiny, working pieces of code (that are so small that they are trivial to troubleshoot), an occasional use of spec and pre-/postconditions, and careful reading of the code we have written. One of the errors - re-frame complaining about being passed a function because we mistakenly invoked a two-argument version of it - could just as well happen in an equally dynamically typed JavaScript.</p>\n<p><strong>Setup from scratch</strong> - it will be necessary to set up all integration and plumbing (error reporting, logging, metrics, etc.) anew, while we already have these concerns solved in our current Node.js setup. That is unfortunate, but it is just a one-time, and hopefully relatively low cost. And there are typically quite mature and high-quality libraries.</p>\n<p><strong>Dev Tools for React/Redux more mature</strong> - especially the Redux Dev Tools are more mature at useful than re-frisk we use with re-frame. We are working further away from the browser&#39;s native language so using its built-in and quite evolved tools isn&#39;t always that helpful. We need cljs-devtools with custom formatters etc. to get what JavaScript developers get out of the box. On the other hand, they have nothing like the REPL so in total we are on the winning side :-)</p>\n<h4 id=\"aside-what-makes-the-js-clj-transition-easier\">Aside: What makes the JS -&gt; Clj transition easier</h4>\n<p>Transitioning from JavaScript to Clojure(Script) is easier than from Java, especially in this team, for a couple of reasons:</p>\n<ul>\n<li>We rarely use a debugger for Node so we won&#39;t miss it. (Though e.g. Cursive&#39;s debugger is available and possibly as good as Node&#39;s?)</li>\n<li>JS is dynamically typed so that is nothing new to us.</li>\n<li>We already structure code in modules with pure function, using very little object-oriented programming.</li>\n<li>We are already used to destructuring from ES6.</li>\n<li>We already transpile (and webpack) our JavaScript so using ClojureScript that needs transpilation doesn&#39;t really add a new step.</li>\n</ul>\n<h2 id=\"our-experiences-so-far\">Our experiences so far</h2>\n<p>Plus:</p>\n<ul>\n<li>Hot reloading works AND preserves state</li>\n<li>You can bring the app into any desired state easily from the REPL without clicking around</li>\n<li>You can interact with and explore the live app in its current state from the REPL</li>\n<li>We get useful warnings from re-frame when we are missing a handler or a query</li>\n<li>See also our <a href=\"https://techblog.telia.no/blog/experience-awesome-productivity-with-clojurescript-s-repl/\">Experience: Awesome productivity with ClojureScript&#39;s REPL</a></li>\n</ul>\n<p>Minus:</p>\n<ul>\n<li>Redux DevTools are better; in re-frisk we could only see the current, not past states (NOTE: That has been fixed in the latest version of re-frisk)</li>\n<li>Errors in the browser are often more difficult to troubleshoot (despite working source maps ;)). Positive: it often names the failing component.</li>\n</ul>\n<h3 id=\"summary\">Summary</h3>\n<p>Our team is in a unique position as we have multiple people - possibly 100% of the team - that have Clojure and/or ClojureScript experience. Therefore it makes sense to leverage the increased productivity of Clojure(Script). At the same time, the developers will be more happy, work harder, and less likely to leave. And we might have a unique opportunity to overcome our chronic hiring challenges by offering something few others do.</p>\n<p>So far, the past few weeks, has our experience been very positive.</p>\n<h2 id=\"appendix-our-stack\">Appendix: Our stack</h2>\n<p>We have selected Reagent (react wrapper) and re-frame (change+state handling, derived state). This combination is battle-tested, mature, and popular. Reagent is attractive because it requires zero boilerplate, you just write functions with Hiccup data to create components, so it is much easier to sell to developers than Om. Re-frame is also quite close to Redux and thus easier to understand for a team used to Redux. The main disadvantage is that there is no native server-side rendering (which might be important for us); people solve it by running the code on the JVM&#39;s JavaScript engine or by running it on Node.js. There are also rough edges around usage with DevCards due to the reliance on global state.</p>\n<p>We have also considered Om Next, as it is nicely &quot;decomplected,&quot; has nice features such as undo and optimistic changes, and supports server-side rendering natively. But it is more verbose (you need to define a class with a <code>render</code> function) and has steeper learning curve and is thus more difficult to &quot;sell&quot;. (I would actually consider <a href=\"https://fulcrologic.github.io/fulcro/vsom-next.html\">Falcro</a> instead; it provides less freedom but is easier to set up and provides some features Om Next cannot.)</p>\n<p><em>(You might want to read other posts from <a href=\"/tags/nettbutikk\">our rebellious product development series</a>)</em></p>\n","path":"blog/from-javascript-to-clojure-script-writing-a-webshop-again","excerpt":"In which I explain why Norway's second largest mobile operator is experimenting with using Clojure and ClojureScript instead of Node and JavaScript for its new webshop and what the experience has been so far."},{"title":"Experience: Awesome productivity with ClojureScript's REPL","date":"2017-12-18T00:00:00.000Z","author":"Jakub Hol√Ω","tags":["nettbutikk","b2b","clojurescript"],"contents":"<p>What&#39;s the deal with ClojureScript? How can you justify picking such a &quot;niche&quot; language? I have recently experienced a &quot;wow&quot; session, demonstrating the productivity gains of ClojureScript and the interactive development it enables thanks to its REPL. I would like to share the experience with you. (If you have never heard about it before - it is a modern, very well designed Lisp that compiles to JavaScript for frontend and backend development. It comes with a REPL that makes it possible to reload code changes and run code in the context of your live application, developing it while it is running.)</p>\n<p><em>Aside - about us: <a href=\"https://telia.no\">Telia Norge</a> is Norway&#39;s second largest mobile operator. Our team has spent the past three years with Node.js, React, and (eventually) Redux creating a great webshop (for hardware and subscriptions) to replace an off-the-shelf one, with a great success. Now we set out to make also the lives of our business customers much better - and we picked Clojure and ClojureScript for that.</em></p>\n<p>The short story. I was adding an Ajax call, massaging data into the format it needed, triggering it from the UI, and handling its result or failure - a classical plumbing work. Being able to run any code from my IDE against the live, running application, accessing and changing its state at will, testing tiny code changes - all that resulted in a super quick feedback loop, enabling me to convert quickly on to working code.</p>\n<p>One troublesome part of the code was the function formatting the application state into the form that the backend <code>submit-order</code> required. From a backend error about missing data, I was able to quickly go to running the formatting function against the actual application state, easily comparing the state and formatting output, never leaving my IDE and beloved keyboard shortcuts. As needed, replicating local variables and running parts of the function to zoom in on a particular part, fixing mistakes, and re-running, until all worked.</p>\n<p><em>In JavaScript/Redux I would have used the Redux DevTools to explore the state, code hot reloading to update the formatting function, and the debugger to explore the output and find the bugs. I would have likely hardcoded the data so as not to loose them upon code reload and commented out the remote call itself. And I would click a button to trigger the functionality.</em></p>\n<p>Another case in point was the display of an error message when the Ajax call failed. As usually, the code did not work at first. Using the REPL, bypassing the UI and browser, I was able to run the &quot;subscription&quot; that should have fetched the error message from the application state and supply it to the Reagent/React component, discovering the wrong data path, and go on to interactively develop the component (watching the magic of the browser updating at the command of my fingers).</p>\n<p><em>In JavaScript/Redux I could have used the React and Redux DevTools to look at the actual data. But I don&#39;t know of a good way to debug the <code>connect</code> function extracting the relevant part of the state. (Well, I could - but never did - try to use the debugger. Typically I would add a few <code>console.log</code> to it.) Interactively developing the component would work just as well, as long as I would do something not to loose the state upon reload.</em></p>\n<p>Having direct access to the application state, I was able to effortlessly simulate all the possible cases (resubmission, call in progress, success and error response) and ensure they were correctly handled by the UI.</p>\n<h2 id=\"comparison-with-vanilla-javascript-and-redux\">Comparison with vanilla JavaScript and Redux</h2>\n<p>The React and Redux Dev Tools are very good. Hot code reloading works - when it works. The debugger is your good friend. I have been told that the application should have been able to preserve its state even as the code is hot reloaded, though that has not been my experience. (But that was perhaps because of local component state, not the global app state?) You can simulate the user by sending supported actions from the Redux Dev Tools.</p>\n<p>I believe that some people might have managed to get close to the ClojureScript experience even with JavaScript and Redux. But I have never been able to match that. I have had pages that denied to be hot-reloaded despite my best efforts, state that was reset, and changes being ignored (because I mistakenly mutated data, oh the horror). The out of the box experience of ClojureScript is much better because it has been designed around immutability and explicit state management. And it has the magic of REPL that enables me to interact with the live, running application - the ultimate development tool.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>My experience is that the cycle of problem discovery - troubleshooting - fix is much shorter in Clojure and ClojureScript thanks to the REPL. And when you really adopt REPL-driven development, you actually have to deal with troubleshooting problems much less since you produce small, working code changes.</p>\n<p>To be frank, there are also some downsides. You can read about the reasons for picking Clojure(Script) and the benefits and drawbacks we have considered and experienced in <a href=\"/blog/from-javascript-to-clojure-script-writing-a-webshop-again/\">From JavaScript to Clojure(Script): Writing a webshop, again</a>.</p>\n<p><em>(You might want to read other posts from <a href=\"/tags/nettbutikk\">our rebellious product development series</a>)</em></p>\n","path":"blog/experience-awesome-productivity-with-clojurescript-s-repl","excerpt":"What's the deal with ClojureScript? How can you justify picking such a \"niche\" language? I have recently experienced a \"wow\" session, demonstrating the productivity gains of ClojureScript and the interactive development it enables thanks to its REPL‚Ä¶"},{"title":"The Telia Identity API","date":"2016-09-05T00:00:00.000Z","author":"Caroline Olsen","tags":null,"contents":"<p>The Telia Identity API is now available as a selective beta test! In order for developers to use our API, we wrote the corresponding documentation using the readme.io developer hub. The guys behind Readme.io were so impressed with our documentation that they wanted us to write a blog post about it! <a href=\"https://blog.readme.io/hello-world-meet-telia/\">You can read the blog post here</a>.</p>\n<h2 id=\"what-is-the-telia-identity-api-\">What is the Telia Identity API?</h2>\n<p>The Telia Identity API allows third party applications to verify the identity of end users as well as obtaining their profile information. However, the third party client can only obtain the user‚Äôs profile information after the user gives their consent, placing the end user‚Äôs privacy before anything else.</p>\n<p>The API also provides a seamless experience across applications by providing single-sign-on. Meaning that the user signs in only once and are then authenticated on all their connected applications. By authentication the user through their smartphone, we hope to create a more frictionless sign-in solution than the more traditional username/password model.</p>\n<p>We wanted to create an API that was simple and fun to implement for developers. We hope we have achieved this, but we would love to get feedback from developers using our API.\n<a href=\"https://identity.developer.telia.no/docs/\">You can check out the documentation here</a>.</p>\n","path":"blog/the-telia-identity-api","excerpt":"The Telia Identity API is now available as a selective beta test! In order for developers to use our API, we wrote the corresponding documentation using the readme.io developer hub. The guys behind Readme.io were so impressed with our documentation‚Ä¶"},{"title":"Today we write the legacy code of tomorrow","date":"2016-07-20T00:00:00.000Z","author":"Jakub Hol√Ω","tags":["nettbutikk","clean code"],"contents":"<p>Our code is a mess. And that is the way it should be.</p>\n<p>No matter how good code we write today, it will need to be fixed tomorrow. Our understanding of the business domain evolves, the business processes and needs themselves evolve, the technical tools (language, framework, libraries) and non-functional requirements evolve. Thus our code will inevitably become outdated.</p>\n<p><em>A part of the <a href=\"/tags/nettbutikk\">series Nettbutikk Team&#39;s Experiences and Experiments</a></em></p>\n<p>For the purpose of this post, contrary to <a href=\"https://theholyjava.wordpress.com/2011/04/18/what-do-i-mean-by-a-legacy-code/\">other popular definitions</a>, I define <em>legacy code</em> as <em>code that we would have written differently today (and might thus need to update)</em>. The main point is that code is a like a living system: either it evolves - or it rots. You have to constantly come back to the old code and - much more importantly - old design and update it to keep up to date with the current needs and ways of doing things. Otherwise the code base becomes so much of a mess, that it will be really hard to change.</p>\n<p>In an ideal world, we would always keep all the code and designs up to date. In a real world, that is not possible. Our resources are limited and we need to maintain a dynamic balance (swaying once more on the one then the other side) between the business needs to keep (future) changes quick and cheap (maintainability, adaptability) and keeping up to date with the market (implementing fixed-date changes, adding new functionality). If you need wood to survive the winter, you can&#39;t spend the whole autumn sharpening your axe - but without sharpening it, you won&#39;t be able to cut enough trees.</p>\n<h3 id=\"examples-from-our-webshop\">Examples from our webshop</h3>\n<p>There are quite a few things that have become outdated and we are improving or plan to improve eventually:</p>\n<ul>\n<li>We have a hack featuring a &quot;fake phone&quot; to enable customers to buy only a SIM card because the original design assumed that the customer will always be buying a phone and we needed to add support for this quickly</li>\n<li>The data that we pass to the frontend is difficult to use (we need multiple lookups and data combination to show the UI)</li>\n<li>The logging and error reporting code became too complex. We need a new, simple API tailored to our needs.</li>\n<li>The same thing has different name in different contexts (e.g. &quot;phone&quot;, &quot;phoneNumber&quot;, &quot;number&quot;).</li>\n<li>We use a dead React Flux library</li>\n<li>We have a mix of ES5 and ES6 code</li>\n<li>We have a mix of old and new style of React components</li>\n<li>We have a few ways of passing data to React components - using props, fetching them from the Store, ... - not one unified way (as our understanding of the best way to do this in our context has evolved a lot)</li>\n<li>Etc. etc. etc.</li>\n</ul>\n<p>Fortunately there are also many things that we have already improved. As always, this is an ongoing process.</p>\n<h3 id=\"conclusion\">Conclusion</h3>\n<p>No matter what you do, parts of your code will &quot;rot&quot; and get outdated while you are trying to keep up with the always changing environment. That is inevitable. You don&#39;t have the infinite resources necessary to prevent it - but you can (and must) use some time to keep the rot in check and to fight it back. Accept that it will happen, don&#39;t get too in love with your code since you will eventually need to change or replace it anyway, and try to maintain a good, ever-shifting balance between new development and updating the existing code and design.</p>\n","path":"blog/today-we-write-the-legacy-code-of-tomorrow","excerpt":"Our code is a mess. And that is the way it should be."},{"title":"Why we practice fronted-first design (instead of API-first)","date":"2015-12-05T00:00:00.000Z","author":"Jakub Hol√Ω","tags":["nettbutikk","design"],"contents":"<p>Alex has introduced us to the idea of front-end first design: You start by creating the front-end (browser) code. As you discover data or API calls that you need, you mock them. When the UI stabilizes, you use the mocked APIs and data to create the backend with exactly the functionality and exactly the data needed by the UI. The end result is a simpler application.</p>\n<p><em>A part of the <a href=\"/tags/nettbutikk\">series Nettbutikk Team&#39;s Experiences and Experiments</a></em></p>\n<p>We are trying to adopt this as our approach because it is so sensible. Whenever we work with an API that wasn‚Äôt designed with the actual client needs in mind, we experience unnecessary friction and have to do various workarounds and adaptations so front-end-first absolutely makes sense to us. (E.g. when working with a REST API designed in line with REST principles ‚Äì but not with our needs, resulting in a too chatty communication and more complex code.)</p>\n<p>Of course there are same limitations. It is more challenging when you need to support different clients. And you need to take into account not just what the UI wants but also what is reasonably possible in the constraints of the existing system. You want to avoid a big gap between the two ‚Äì we still remember the pain of integrating OOP and relational databases and the complexity of pitfalls of Object-Relational Mappers such as Hibernate, that try to bridge the two.</p>\n<h3 id=\"conclusion\">Conclusion</h3>\n<p>Fronted-first design rocks (for us). Try it too and see whether you too get a simpler application code and shorter time to market.</p>\n","path":"blog/why-we-practice-fronted-first-design-instead-of-api-first","excerpt":"Alex has introduced us to the idea of front-end first design: You start by creating the front-end (browser) code. As you discover data or API calls that you need, you mock them. When the UI stabilizes, you use the mocked APIs and data to create the‚Ä¶"},{"title":"Moving Too Fast For UX? Genuine Needs, Wrong Solutions","date":"2015-11-12T00:00:00.000Z","author":"Jakub Hol√Ω","tags":["nettbutikk","lean","ux"],"contents":"<p>Our UX designer and interaction specialist ‚Äì a wonderful guy ‚Äì has shocked us today by\ntelling us that we (the developers) are moving too fast. He needs more time to do\nproper user experience and interface design ‚Äì talk to real users, collect feedback,\ndesign based on data, not just hypotheses and gut feeling. To do this, he needs us\nto slow down.</p>\n<p><em>A part of the <a href=\"/tags/nettbutikk\">series Nettbutikk Team&#39;s Experiences and Experiments</a></em></p>\n<p>We see a common human &quot;mistake&quot; here: where the expression of a genuine need gets mixed in with a suggestion for satisfying it. We are happy to learn about the need and will do our best to satisfy it (after all, we want everybody to be happy, and we too love\nevidence-based design) but we want to challenge the proposed solution. There is never\njust one way to satisfy a need ‚Äì and the first proposed solution is rarely the best one (not mentioning that this particular one goes against the needs of us, the developers).</p>\n<p>So after some thought we proposed a better solution for satisfying the &quot;better UX&quot;\nneed: our rewrite of the current system will simply copy the design of the existing\nsystem, and we will change it later on, when UX is ready to start experimenting with a new design. Thus we can get feedback on technical aspects of the new solution\n(performance, etc.) soon, while the UX-team designs a solution based on thorough user\ninsight and data.</p>\n<p>Do you also experience that people mix needs and (suboptimal) solution proposals?\nPerhaps you do it yourself?</p>\n","path":"blog/moving-too-fast-for-ux-genuine-needs-wrong-solutions","excerpt":"Our UX designer and interaction specialist ‚Äì a wonderful guy ‚Äì has shocked us today by\ntelling us that we (the developers) are moving too fast. He needs more time to do\nproper user experience and interface design ‚Äì talk to real users, collect‚Ä¶"},{"title":"Extreme Minimalism - replacing shop.netcom.no one tiny bit at a time (Smidig 2015 transcript)","date":"2015-11-03T00:00:00.000Z","author":"Jakub Hol√Ω","description":"Transcript of my Smidig 2015 lightning talk","tags":["nettbutikk","product development","lean"],"contents":"<p>Replacing legacy systems typically starts with an excitement, proceeds through\nmonths or years of work, and results in a failure. The incremental strangling\nof the old shop.netcom.no is a very different story and the approach is\nrightfully called &quot;extreme&quot; by the rest of the organization. Read on to learn how\nwe have been replacing the legacy webshop one tiny bit at a time. I also hope\nto share my continual amazement at how much work can be postponed to be able to\ndeliver a &quot;feature&quot; early.</p>\n<p><em>A part of the <a href=\"/tags/nettbutikk\">series Nettbutikk Team&#39;s Experiences and Experiments</a></em></p>\n<p>(<a href=\"https://vimeo.com/145011983\">See Extreme minimalism: Replacing shop.netcom one tiny bit at a time at Vimeo</a> (10 min).)</p>\n<h2 id=\"my-best-project-ever\">My best ‚Äòproject‚Äô ever</h2>\n<p>Nettbutikk.netcom.no is the best project - though I rather say product development -\nI have ever been to. When asked why, this was my answer:</p>\n<blockquote>\n<p>Full stack &amp; full control: frontend, backend, ops. Great people &amp; ideally\nsmall team. Very pragmatic, minimalistic and evolutionary approach to the dev\nprocess. Working closely with the business and seeing the app actually matters\nto them and influences real people every day.</p>\n</blockquote>\n<p>I.e.</p>\n<ol>\n<li>We do everything - front-end, back-end, operations, we deploy whenever we want to.</li>\n<li>The team is really small and totally awesome</li>\n<li>We sit together with the business and work together all the time</li>\n<li>The application is really important for the business - and every line of code\nI release to production can improve (or destroy) the experiences for thousands\nof people.</li>\n</ol>\n<p>There are many things I am excited about in this project but today I want to focus on one thing.</p>\n<p>Normally when people speak about their favourite project, they brag about what\nthey did. I want to brag about what we have not done.</p>\n<h2 id=\"background-extreme-minimalism-mind-set\">Background: Extreme Minimalism Mind-set</h2>\n<p>One of the great things about this team is its minimalist mind-set:</p>\n<ol>\n<li>We get by with the minimal process possible, and continually evolve it,\nadd and (preferably) remove from it as we learn and our needs change. No Jira,\nno demos (the business sees every new change anyway), no retrospectives (we\npractice continuous improvement), ...</li>\n<li>We are library and tool skeptics (thanks, Alex!) - we only add a it if we\nreally need to, if skipping it or writing it ourselves isn‚Äôt reasonable</li>\n<li>We always try to trim a feature down to the bare minimum and release the\nsmallest possible chunk of functionality that adds any value to us,\nthe business, or our customers &lt;--- this is what I will focus on today</li>\n</ol>\n<h2 id=\"the-goal-of-nettbutikk-netcom-no\">The goal of nettbutikk.netcom.no</h2>\n<p>NetCom had - or actually has - this huge, inflexible webshop rented from a 3rd\nparty and customized. But the business wanted something different, something\nthat would actually fit their needs, evolve continuously, enable them to experiment.\nSomething where the time from an idea to production wouldn&#39;t be months but days\nor hours.</p>\n<p>So they have decided to get a few skilled developers, having them sitting together\nwith the business (instead of being outsourced) and writing their own webshop.</p>\n<p>To me this sounds very scary. As far as I know, most of the &quot;let‚Äôs ditch this\nnon-trivial software and write it from scratch&quot; projects fail badly.</p>\n<p>And when you think about it, you need a lot to implement a webshop:</p>\n<p><img src=\"../../images/extreme_minimalism-webshop_needs.png\" alt=\"webshop_needs\"></p>\n<ul>\n<li>You obviously need a database</li>\n<li>Get data from primary sources and transform the for the views</li>\n<li>Enhance / override the primary data</li>\n<li>Product listing (for all product types)</li>\n<li>Product details page (for all product types)</li>\n<li>Checkout, payment</li>\n<li>Filtering, search, categories</li>\n<li>Analytics</li>\n<li>user login</li>\n<li>(and certainly many things I have forgotten)</li>\n</ul>\n<p>This sounds like at least 1 year project with a big-bang release at the end.\nYou cannot release half of a webshop, right? You can‚Äôt release a perfect webshop\nwithout checkout, where people can‚Äôt actually buy stuff.</p>\n<h2 id=\"our-first-release-\">Our first release:</h2>\n<p><strong>Product details page of a single product variant</strong></p>\n<p>Well, our first release was a single page - product details of one variant of\none product. We have released it in just a few weeks (though more than the two\nI hoped for).</p>\n<h2 id=\"here-it-is-\">Here it is:</h2>\n<p><img src=\"../../images/extreme_minimalism-nettbutik_r1-page1.png\" alt=\"release 1 page 1\"></p>\n<p>So you would navigate the old shop and when you clicked on iPhone 6 plus 16GB,\nyou would come to our page. You could select a color, subscription, ...</p>\n<p><img src=\"../../images/extreme_minimalism-nettbutik_r1-page2.png\" alt=\"release 1 page 2\"></p>\n<p>... services and accessories. And when you clicked on the &quot;Fortsett&quot; button, you\nwould go to checkout in the old shop again. And even the &quot;shopping cart&quot; - the\nconfiguration of your order - would mostly just reuse the shopping cart in the\nold shop via an ugly iframe hack.</p>\n<h2 id=\"so-there-is-a-lot-we-did-not-need-to-do-\">So there is a lot we did not need to do:</h2>\n<p><img src=\"../../images/extreme_minimalism-webshop-not_done.png\" alt=\"webshop-not_done\"></p>\n<p>Later, we extended it to all variants, all iPhones, eventually all phones,\nphone listing, all product types, ... .</p>\n<p>Nowadays, 10 months since start, we have everything, only the checkout still\nlives in the old system. (And we are looking forward to getting rid of it as well!)</p>\n<h2 id=\"the-four-techniques\">The Four Techniques</h2>\n<p>How do we do it? How do we trim the next chunk of functionality to the total minimum? We\napply these techniques:</p>\n<p><strong>You Don‚Äôt Need It Just Yet. Postpone it!</strong></p>\n<ol>\n<li>Do it manually</li>\n<li>Hardcode it</li>\n<li>Reuse</li>\n<li>Slice &amp; Dice</li>\n</ol>\n<p>The key principle is &quot;You Don‚Äôt Need It Just Yet&quot;. There is a lot you truly need,\nbut most likely it can wait a day - or a few weeks\n(and you can hardcode it or do it manually in the meantime).\nThe magic words &quot;in the first phase [or day]&quot; (and, possibly, &quot;experiment&quot;) can\nhelp you to get this across to the business people that are always eager to get\nmore cool stuff out. (And, of course, by doing less now we get eventually more done!)</p>\n<p>It is also very important to remember - and to communicate to the business - that\nyou only need not to be worse than the existing functionality - improvements,\nbug fixes, and additions may wait. (Even though we more less managed to follow\nthis maxim, everything we did is better and performs better than in the old shop :-) .)</p>\n<ol>\n<li>Do it manually - you can get shockingly far with doing things manually.\nDuring many months, our heroic biz people duplicated data between the old and\nnew webshop instead of automatically syncing them. And we still need to add\nnew phones manually to the webshop.</li>\n<li>Hardcode it - with just a few minutes to deploy, the developers sitting with\nthe business, and possibly only a small subset of\nproducts, a lot may be hard-coded instead of having a CMS to add/override data.\nThese days, when we need to show &quot;Checkout down for maintenance,&quot; we still just\nchange it in code, release, and then re-deploy the previous version.</li>\n<li>Reuse what is there, even though it certainly gets ugly quickly. We have\nreused the shopping cart via an iframe and still use the checkout process in the\nold shop.</li>\n<li>Slice &amp; Dice: Release the smallest subset of the feature for just one use\ncase / target group first. We have started with a page for a single product\nvariant - which decreased the complexity considerably. And when developing a new\ncart functionality, we applied it first just to accessories - and only the part\nusers cannot see in the UI (though they use it).</li>\n</ol>\n<p>I am constantly surprised how far we can get with these.\nIt works best when having colleagues that challenge you on doing even less, on\nhardcoding and doing manually a little more than you would want to. (We are\ndevelopers after all, we love automation!)</p>\n<h2 id=\"always-ask-\">Always ask:</h2>\n<p><strong>Do I need it <em>now</em>?</strong></p>\n<p>(Hint: Most of the time the answer is no.)</p>\n<h2 id=\"want-to-know-more-\">Want to know more?</h2>\n<ul>\n<li><a href=\"https://netcom.no/disrupt-us\">Work with me!</a></li>\n<li>Contanct me at Twitter <a href=\"https://twitter.com/HolyJak\">@HolyJak</a></li>\n<li>Learn more about our journey at the <a href=\"http://techblog.telia.no/\">Telia Tech Blog</a></li>\n</ul>\n<p>Thank you!</p>\n","path":"blog/extreme-minimalism-replacing-shop-netcom-no-one-tiny-bit-at-a-time-smidig-2015-transcript","excerpt":"Replacing legacy systems typically starts with an excitement, proceeds through\nmonths or years of work, and results in a failure. The incremental strangling\nof the old shop.netcom.no is a very different story and the approach is\nrightfully called‚Ä¶"},{"title":"Introducing the Series Nettbutikk Team's Experiences and Experiments","date":"2015-11-01T00:00:00.000Z","author":"Jakub Hol√Ω","tags":["nettbutikk","product development","lean"],"contents":"<p><em>A part of the <a href=\"/tags/nettbutikk\">series Nettbutikk Team&#39;s Experiences and Experiments</a></em></p>\n<p>We are starting a new blog series tracking the experiences and (process)\nexperiments of the team behind <a href=\"https://nettbutikk.netcom.no\">nettbutikk.netcom.no</a>.\nThis is the best product development process and team I have ever part of and\nit has been called &quot;extreme&quot; for a couple of reasons. We are quite excited about it\nand would like to share our experiences, successes, and failures for the amusement\nand inspiration of our readers.</p>\n<p>When asked why we think this team and product development were so great, this\nwas my answer:</p>\n<blockquote>\n<p>Full stack &amp; full control: frontend, backend, ops. Great people &amp; ideally\nsmall team. Very pragmatic, minimalistic and evolutionary approach to the\ndev process. Working closely with the business and seeing that the app actually\nmatters to them and influences real people every day.</p>\n</blockquote>\n<h2 id=\"what-is-the-project-about-\">What is the project about?</h2>\n<p>The project started as an experiment. It grew out of the pain with the old\nhuge and inflexible webshop rented from a third party. The business wanted\nsomething that would fit their needs, that could evolve, and enable them to experiment.\nSomething, where the time from an idea to production would be days or hours, not\nmonths.</p>\n<p>So they decided to get a small team of highly skilled developers, sitting\nand working together with the business, and write their own, better webshop.\nThe hypothesis was that even with expensive skilled Norwegian developers, it\nwould pay off thanks to more satisfied customers that would more easily find\nwhat they wanted.</p>\n<h2 id=\"why-is-it-considered-extreme-\">Why is it considered &quot;extreme&quot;?</h2>\n<p>There are multiple things considered &quot;extreme&quot; about this team. We have released to\nproduction, to real customers, only in a few weeks, including just a single\nproduct page. We deploy whenever we want to, and do our own operations, using\nthe cloud instead of the enterprise infrastructure. Our development process is\nminimalistic, we don&#39;t follow a methodology, we create (and re-create) our own,\nusing only a physical Kanban board instead of Jira. And we run on Node.js instead\nof the standard JVM. We have ditched e-mail and started using Slack instead.</p>\n<h2 id=\"a-little-of-history\">A little of history</h2>\n<p>The project started in February 2015 as an experiment. The first release - a\nsingle page for one variant of one phone - came after 7 weeks (though the\noptimists hoped for 2). Then it steadily grew and a month ahead of the planned\nexperiment end it was deemed successful. By summer, the whole webshop with the\nexception of checkout was in the new system, and it was better and more\nperformant then the old one. That enabled a large re-design for a summer campaign.\nThe business started with A/B experiments and there was a steady flow of new\nfeatures and improvements, with focus shifting gradually towards implementing\ncheckout directly in the new webshop. When the newest iPhone arrived, the system\nhandled the increased load formidably (contrary to some backend systems, sadly).</p>\n<h2 id=\"meet-the-team\">Meet the team</h2>\n<p>The core team that started the journey consists of:</p>\n<ul>\n<li>Alex York, master of all things CSS and JS with a .NET background, love of TDD,\n  and ultimate judge of code quality and understandability</li>\n<li>Jakob Lind, the get-things-done guy, an Emacs and functional programming enthusiast,\n  always on lookout for better ways to do things</li>\n<li>Jakub Hol√Ω, the operations and data specialist and Clojre(Script) evangelist</li>\n<li>Ketil Jensen, our &quot;agile coach,&quot; and a shield and liaison between us and the rest of the organization</li>\n<li>Magnus Indregard, our primary business representative</li>\n</ul>\n<p>All of the developers are very capable, they all are very pragmatic and favour\nthe lean way. Yet they have different background and approaches. The similarities\ngive us a strong push towards minimalism and getting stuff out, while the\ndifferences spark valuable discussions and lead to a much better process and code.</p>\n","path":"blog/introducing-the-series-nettbutikk-team-s-experiences-and-experiments","excerpt":"A part of the series Nettbutikk Team's Experiences and Experiments"},{"title":"Nettbutikk: The No Status Standup Experiment","date":"2015-11-01T00:00:00.000Z","author":"Jakub Hol√Ω","tags":["nettbutikk","product development","lean"],"contents":"<p><em>A part of the <a href=\"/tags/nettbutikk\">series Nettbutikk Team&#39;s Experiences and Experiments</a></em></p>\n<p>The Nettbutikk team likes to challenge all established truths. Jakob Lind has\ncome with with an excellent question: do we need standups? Do we all need to\nstand in front of our Kanban board and discuss what was and will be, especially\nsince we often already know that, thanks to communication all the time?</p>\n<p>We have agreed to keep the standups but to limit them to:</p>\n<ol>\n<li>A brief review of what has been deployed to production the previous day</li>\n<li>Any blockers, problems, and requests for help</li>\n</ol>\n<p>i.e. skipping the reporting of the status of tasks if they progress &quot;according\nto the plan&quot; and there is nothing noteworthy about them. Of course participants\ncan ask, if they want to know. And they should do so, if they e.g. feel a task is\ntaking too long.</p>\n<p>Minimalism for the win!</p>\n","path":"blog/nettbutikk-the-no-status-standup-experiment","excerpt":"A part of the series Nettbutikk Team's Experiences and Experiments"},{"title":"Upgrade or not to upgrade? The eternal dilemma","date":"2015-10-20T00:00:00.000Z","description":"The pain of upgrading project dependencies vs. not upgrading","author":"Jakub Hol√Ω","tags":["nettbutikk","experience","development","learning"],"contents":"<p><em>A part of the <a href=\"/tags/nettbutikk\">series Nettbutikk Team&#39;s Experiences and Experiments</a></em></p>\n<p>Handling dependencies is one of important challenges in any software project -\nand especially in the fast-moving JavaScript world. Our\n<a href=\"nettbutikk.netcom.no\">Nettbutikk</a> team just had a heated discussion about\nhandling upgrades of our dependencies that continuous our learning journey lined\nwith failures (or rather &quot;experiments that generated new knowledge&quot; :-)).</p>\n<h2 id=\"failed-attempt-one-let-tools-do-it\">Failed attempt one: Let tools do it</h2>\n<p>Originally we let <code>npm</code> automatically\ndo minor upgrades but that turned out to be problematic as even minor version\nchanges can introduce bugs and having potentially different (minor) versions on\nour different machines and in production makes troubleshooting difficult.</p>\n<p>Also, this only takes care about minor version changes. When we decided to do\nthe bigger updates, we had a lot of work and testing to do, making sure all the\nnew versions work together. Troubleshooting of upgrade problems was difficult\nsince many libraries were changed at once so pinpointing the source of a new\ndefect was nontrivial.</p>\n<h2 id=\"failed-attempt-two-let-a-human-do-it\">Failed attempt two: Let a human do it</h2>\n<p>Next we decided to freeze the library versions completely and let the one of us\nthat had the operations role that week run <code>npm outdated</code>, update all\ndependencies, and verify everything still worked.</p>\n<p>Thus we ensured that we were almost always up-to-date and that we typically had\nonly a small job to do, with just a small potential for problems. However it\nwasn&#39;t frictionless either. It might require one or few hours (for proper\ntesting and occasional troubleshooting) every week, a time we would have rather\nused on creating new value. And sometimes the upgrade did introduce problems -\nsome spot and fixed immediately, but some taking more time to discover and fix.\nOnce it took two weeks to find out that something broke due to a <code>Reflux</code> upgrade -\nand finding out that the cause was the upgrade wasn&#39;t easy.</p>\n<h2 id=\"new-experiment-upgrade-as-needed\">New experiment: Upgrade as-needed</h2>\n<p>Our reliable though-challenger Alex pointed out that upgrades give us typically\nlittle value at a relatively high cost. So we have decided to try not upgrading\nlibraries unless we would have a good reason to do it (such as a known security\nproblem or a new functionality we want). It is obviously not optimal and the\nupgrades might be big and painful but we will try it for a while and evaluate\nhow it works for us.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>Handling and upgrading dependencies is difficult and costly. It&#39;s important to\nevaluate the cost-benefit ration and experiment to find the &quot;least bad&quot; approach and\nbalance for a particular team. Development is fun.</p>\n","path":"blog/upgrade-or-not-to-upgrade-the-eternal-dilemma","excerpt":"A part of the series Nettbutikk Team's Experiences and Experiments"},{"title":"Afternoon-hack","date":"2015-10-19T00:00:00.000Z","description":"Afternoon Hack Blog post","author":"Ketil Jensen","tags":["hackday","agile","learning","product development"],"imgUrl":"../../images/hack-day-presentation-2.jpg","contents":"<p>A few thursdays ago we arranged our very first hack day at Telia. The event was attended by 15 people, forming 5 different teams. Snacks and drinks were on the house. Pizza was served to the hungry late stayers. But most importantly: During the day we saw many good ideas shape up and worked on. A passionate group worked hard throughout the day. Some working on internal tools, other groups on customer facing products and new concepts. The results were presented at 9 AM the morning after. And after a vote later in the afternoon, we could announce two &quot;winners&quot;. The attendees reported back that they really enjoyed our afternoon-hack event, so we will definitely do more of that in the future.</p>\n<blockquote>\n  <p>\n    I have not failed. I&#39;ve just found 10,000 ways that won&#39;t work.\n  </p>\n  <footer><cite title=\"Thomas A. Edison\">Thomas A. Edison</cite></footer>\n</blockquote>\n\n<h3 id=\"why-are-we-doing-it-\">Why are we doing it?</h3>\n<p>First and foremost: To learn! If TS is going to stay competetive in the Telco market, then we need to learn faster than our competitors. We know we need to find new products and services to attract new customers and retain those that we already have. To do that we think we need to do at least 2 things:</p>\n<ul>\n<li>Create an environment where experimentation and learning can happen</li>\n<li>Run experiments</li>\n</ul>\n<p>In a hectic work day it is not realistic to think that people will be able to create time and space to innovate. At least not in the short run. Thus, we need to change the envioronment.  Our hypothesis was that a hack day (or a half hack day), could be such a learning environment. After the first experiment we still believe that, but we need to run more experiments to  further improve. Other reasons to arrange a hack day:</p>\n<ul>\n<li>Have fun</li>\n<li>Learn new skills</li>\n<li>Get to know colleagues, also from other departments</li>\n</ul>\n<p>Although having fun and learning new skills is obviously very important (we believe in creating a work place where people can have fun), I want to especially emphasize the importance of the last point above. We believe that events like these can be a really great way to <strong>tear down some of the functional silos that exists in the organization</strong>, to create new relationships across departments. The first time around we had a few from the business side. Next time around we hope to get more people from lots of differents departments to attend: More people from the business side, marketing, sales, HR and so on. </p>\n<h3 id=\"what-is-a-hack-day-\">What is a Hack day?</h3>\n<p>A hack day is a timeboxed event where people meet to work on ideas they have for a new product, play around with new technology, together with other people. This creates an environment where people can focus on developing an idea they have without all the interferences that people normally have in their daily job. </p>\n<h3 id=\"start-small-ship-it-and-improve\">Start small, ship it and improve</h3>\n<blockquote>\n  <p>\n    The only purpose of starting is to finish, and while the projects we do are never really finished, they must ship.<br>  </p>\n  <footer><cite title=\"Seth Godin\">Seth Godin</cite></footer>\n</blockquote>\n\n<p>Thinking small enough can be really difficult, but we believe it to be incredibly important. So we wanted to take this approach when launching hack day. A hack day normally lasts a full day, from morning to afternoon/evening. To start small we decided that our first experiment should be a bit shorter, starting from lunch and lasting to whenever people needed to leave. Starting with a short event made it not only easier for people to attend. It also felt like a safe-to-fail experiment, where we could test out the concept and learn (see &quot;What we learned&quot; below). </p>\n<h3 id=\"show-us-what-you-ve-learned\">Show us what you&#39;ve learned</h3>\n<p>Teams were challenged to present their hacks on the morning after, at 9AM. To keep things transparent and simple we decided to do the presentations in the open office space. Quite a few people got interested in what was going, and with some good presentations being made we managed to raise additional interest in our afternoon hack day. Next time we hope to have even more people joining. People has already started asking when our next event will take place. </p>\n<p>In the afternoon we invited everybody to vote for two winners; best customer facing product and best internal product. No fancy prizes, just the honors.</p>\n<p><img src=\"/images/hack-day-presentation-1.jpg\" alt=\"Presentation of hacks\"></p>\n<h3 id=\"what-we-learned-from-arranging-the-event-\">What we learned from arranging the event?</h3>\n<p>We tried hard to keep our first event as simple as possible. That approach worked really well. The table below summarizes our key learnings from the event, tools and other learnings.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">What</th>\n<th style=\"text-align:left\">How</th>\n<th style=\"text-align:center\">Did it work?</th>\n<th style=\"text-align:left\">Learning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Communication</td>\n<td style=\"text-align:left\"><a href=\"http://slack.com\">Slack</a></td>\n<td style=\"text-align:center\">Yes</td>\n<td style=\"text-align:left\">Slack is awesome</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Idea gathering</td>\n<td style=\"text-align:left\"><a href=\"http://trello.com\">Trello</a></td>\n<td style=\"text-align:center\">Yes</td>\n<td style=\"text-align:left\">Invite broadly to get more ideas</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Voting</td>\n<td style=\"text-align:left\"><a href=\"http://trello.com\">Trello</a></td>\n<td style=\"text-align:center\">Yes</td>\n<td style=\"text-align:left\">You need Trello gold to enable voting</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Registration</td>\n<td style=\"text-align:left\"><a href=\"http://eventbrite.com\">Eventbrite</a></td>\n<td style=\"text-align:center\">No</td>\n<td style=\"text-align:left\">Complicating things</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Presentation</td>\n<td style=\"text-align:left\">In open office area</td>\n<td style=\"text-align:center\">Yes</td>\n<td style=\"text-align:left\">Transparency is king</td>\n</tr>\n</tbody>\n</table>\n<p>Since we decided to do a shorter hack day for our first experiment, we accepted that teams presented concepts as hacks. In fact, the two winning teams did not have a potentially shippable product. Next time around, if we are doing a full hack day, we will focus more on getting some minimum products finished. </p>\n","path":"blog/afternoon-hack","excerpt":"A few thursdays ago we arranged our very first hack day at Telia. The event was attended by 15 people, forming 5 different teams. Snacks and drinks were on the house. Pizza was served to the hungry late stayers. But most importantly: During the day‚Ä¶"},{"contents":"<ul>\n<li>Don&#39;t follow a methodology - lead, explore, learn</li>\n<li>No retro - ongoing process improvement</li>\n<li>Minimal standup (link)</li>\n<li>phys board<ul>\n<li>Current + week milestone + KPIs</li>\n<li>Two lanes</li>\n<li>No done</li>\n</ul>\n</li>\n<li>occasional planning</li>\n<li>biz sitting with devs, talking constantly</li>\n<li>no demos</li>\n<li>release anytime</li>\n</ul>\n<h2 id=\"values\">Values</h2>\n<ul>\n<li>Challenge established practices and truths - especially our own</li>\n<li>Minimalism - process, lib/tool skepticism </li>\n</ul>\n","path":"posts/post-7-process","excerpt":false}],"type":"list"}